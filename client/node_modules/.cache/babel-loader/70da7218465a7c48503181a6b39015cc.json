{"ast":null,"code":"import { parseFilterArgs, functionalUpdate, parseQueryArgs, noop, hashQueryKey, partialMatchKey, hashQueryKeyByOptions } from './utils.mjs';\nimport { QueryCache } from './queryCache.mjs';\nimport { MutationCache } from './mutationCache.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior.mjs';\nimport { defaultLogger } from './logger.mjs'; // CLASS\n\nclass QueryClient {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  mount() {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations();\n        this.queryCache.onFocus();\n      }\n    });\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations();\n        this.queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n  }\n\n  isFetching(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    filters.fetchStatus = 'fetching';\n    return this.queryCache.findAll(filters).length;\n  }\n\n  isMutating(filters) {\n    return this.mutationCache.findAll({ ...filters,\n      fetching: true\n    }).length;\n  }\n\n  getQueryData(queryKey, filters) {\n    var _this$queryCache$find;\n\n    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n  }\n\n  getQueriesData(queryKeyOrFilters) {\n    return this.getQueryCache().findAll(queryKeyOrFilters).map(_ref2 => {\n      let {\n        queryKey,\n        state\n      } = _ref2;\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const query = this.queryCache.find(queryKey);\n    const prevData = query == null ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (typeof data === 'undefined') {\n      return undefined;\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions);\n    return this.queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(queryKeyOrFilters, updater, options) {\n    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(_ref3 => {\n      let {\n        queryKey\n      } = _ref3;\n      return [queryKey, this.setQueryData(queryKey, updater, options)];\n    }));\n  }\n\n  getQueryState(queryKey, filters) {\n    var _this$queryCache$find2;\n\n    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n  }\n\n  removeQueries(arg1, arg2) {\n    const [filters] = parseFilterArgs(arg1, arg2);\n    const queryCache = this.queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const queryCache = this.queryCache;\n    const refetchFilters = {\n      type: 'active',\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  cancelQueries(arg1, arg2, arg3) {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true;\n    }\n\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map(query => query.cancel(cancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    return notifyManager.batch(() => {\n      var _ref, _filters$refetchType;\n\n      this.queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve();\n      }\n\n      const refetchFilters = { ...filters,\n        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n\n  refetchQueries(arg1, arg2, arg3) {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);\n    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      var _options$cancelRefetc;\n\n      return query.fetch(undefined, { ...options,\n        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n        meta: {\n          refetchPage: filters.refetchPage\n        }\n      });\n    }));\n    let promise = Promise.all(promises).then(noop);\n\n    if (!(options != null && options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n\n  fetchQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(arg1, arg2, arg3) {\n    return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(arg1, arg2, arg3) {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n    parsedOptions.behavior = infiniteQueryBehavior();\n    return this.fetchQuery(parsedOptions);\n  }\n\n  prefetchInfiniteQuery(arg1, arg2, arg3) {\n    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n  }\n\n  resumePausedMutations() {\n    return this.mutationCache.resumePausedMutations();\n  }\n\n  getQueryCache() {\n    return this.queryCache;\n  }\n\n  getMutationCache() {\n    return this.mutationCache;\n  }\n\n  getLogger() {\n    return this.logger;\n  }\n\n  getDefaultOptions() {\n    return this.defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    const result = this.queryDefaults.find(x => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.queryDefaults.push({\n        queryKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getQueryDefaults(queryKey) {\n    if (!queryKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.queryDefaults.find(x => partialMatchKey(queryKey, x.queryKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter(x => partialMatchKey(queryKey, x.queryKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    const result = this.mutationDefaults.find(x => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));\n\n    if (result) {\n      result.defaultOptions = options;\n    } else {\n      this.mutationDefaults.push({\n        mutationKey,\n        defaultOptions: options\n      });\n    }\n  }\n\n  getMutationDefaults(mutationKey) {\n    if (!mutationKey) {\n      return undefined;\n    } // Get the first matching defaults\n\n\n    const firstMatchingDefaults = this.mutationDefaults.find(x => partialMatchKey(mutationKey, x.mutationKey)); // Additional checks and error in dev mode\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter(x => partialMatchKey(mutationKey, x.mutationKey)); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n      }\n    }\n\n    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n  }\n\n  defaultQueryOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    } // dependent default values\n\n\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n    }\n\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options != null && options._defaulted) {\n      return options;\n    }\n\n    return { ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.queryCache.clear();\n    this.mutationCache.clear();\n  }\n\n}\n\nexport { QueryClient };","map":{"version":3,"mappings":"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","names":["QueryClient","constructor","config","queryCache","QueryCache","mutationCache","MutationCache","logger","defaultLogger","defaultOptions","queryDefaults","mutationDefaults","mount","unsubscribeFocus","focusManager","subscribe","isFocused","resumePausedMutations","onFocus","unsubscribeOnline","onlineManager","isOnline","onOnline","unmount","isFetching","arg1","arg2","filters","parseFilterArgs","fetchStatus","findAll","length","isMutating","fetching","getQueryData","queryKey","find","_this$queryCache$find","state","data","getQueriesData","queryKeyOrFilters","getQueryCache","map","setQueryData","updater","options","query","prevData","functionalUpdate","undefined","parsedOptions","parseQueryArgs","defaultedOptions","defaultQueryOptions","build","setData","manual","setQueriesData","notifyManager","batch","getQueryState","removeQueries","forEach","remove","resetQueries","arg3","refetchFilters","type","reset","refetchQueries","cancelQueries","cancelOptions","revert","promises","cancel","Promise","all","then","noop","catch","invalidateQueries","invalidate","refetchType","resolve","_ref","filter","isDisabled","fetch","cancelRefetch","meta","refetchPage","promise","throwOnError","fetchQuery","retry","isStaleByTime","staleTime","prefetchQuery","fetchInfiniteQuery","behavior","infiniteQueryBehavior","prefetchInfiniteQuery","getMutationCache","getLogger","getDefaultOptions","setDefaultOptions","setQueryDefaults","result","x","hashQueryKey","push","getQueryDefaults","firstMatchingDefaults","partialMatchKey","process","env","NODE_ENV","matchingDefaults","error","JSON","stringify","setMutationDefaults","mutationKey","getMutationDefaults","_defaulted","queries","queryHash","hashQueryKeyByOptions","refetchOnReconnect","networkMode","useErrorBoundary","suspense","defaultMutationOptions","mutations","clear"],"sources":["C:\\Users\\vaibh\\OneDrive\\Desktop\\college\\web devlopment\\youtube2022-social-app\\client\\node_modules\\@tanstack\\query-core\\src\\queryClient.ts"],"sourcesContent":["import type { QueryFilters, Updater, MutationFilters } from './utils'\nimport {\n  hashQueryKey,\n  noop,\n  parseFilterArgs,\n  parseQueryArgs,\n  partialMatchKey,\n  hashQueryKeyByOptions,\n  functionalUpdate,\n} from './utils'\nimport type {\n  QueryClientConfig,\n  DefaultOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  ResetQueryFilters,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type { CancelOptions, DefaultedQueryObserverOptions } from './types'\nimport type { Logger } from './logger'\nimport { defaultLogger } from './logger'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: QueryOptions<any, any, any>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  private queryCache: QueryCache\n  private mutationCache: MutationCache\n  private logger: Logger\n  private defaultOptions: DefaultOptions\n  private queryDefaults: QueryDefaults[]\n  private mutationDefaults: MutationDefaults[]\n  private unsubscribeFocus?: () => void\n  private unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.queryCache = config.queryCache || new QueryCache()\n    this.mutationCache = config.mutationCache || new MutationCache()\n    this.logger = config.logger || defaultLogger\n    this.defaultOptions = config.defaultOptions || {}\n    this.queryDefaults = []\n    this.mutationDefaults = []\n  }\n\n  mount(): void {\n    this.unsubscribeFocus = focusManager.subscribe(() => {\n      if (focusManager.isFocused()) {\n        this.resumePausedMutations()\n        this.queryCache.onFocus()\n      }\n    })\n    this.unsubscribeOnline = onlineManager.subscribe(() => {\n      if (onlineManager.isOnline()) {\n        this.resumePausedMutations()\n        this.queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.unsubscribeFocus?.()\n    this.unsubscribeOnline?.()\n  }\n\n  isFetching(filters?: QueryFilters): number\n  isFetching(queryKey?: QueryKey, filters?: QueryFilters): number\n  isFetching(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): number {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    filters.fetchStatus = 'fetching'\n    return this.queryCache.findAll(filters).length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.mutationCache.findAll({ ...filters, fetching: true }).length\n  }\n\n  getQueryData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): TQueryFnData | undefined {\n    return this.queryCache.find<TQueryFnData>(queryKey, filters)?.state.data\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    queryKey: QueryKey,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][]\n  getQueriesData<TQueryFnData = unknown>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return this.getQueryCache()\n      .findAll(queryKeyOrFilters)\n      .map(({ queryKey, state }) => {\n        const data = state.data as TQueryFnData | undefined\n        return [queryKey, data]\n      })\n  }\n\n  setQueryData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): TQueryFnData | undefined {\n    const query = this.queryCache.find<TQueryFnData>(queryKey)\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (typeof data === 'undefined') {\n      return undefined\n    }\n\n    const parsedOptions = parseQueryArgs(queryKey)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n    return this.queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    queryKey: QueryKey,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][]\n\n  setQueriesData<TQueryFnData>(\n    queryKeyOrFilters: QueryKey | QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): [QueryKey, TQueryFnData | undefined][] {\n    return notifyManager.batch(() =>\n      this.getQueryCache()\n        .findAll(queryKeyOrFilters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<TQueryFnData = unknown, TError = undefined>(\n    queryKey: QueryKey,\n    filters?: QueryFilters,\n  ): QueryState<TQueryFnData, TError> | undefined {\n    return this.queryCache.find<TQueryFnData, TError>(queryKey, filters)?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void\n  removeQueries(queryKey?: QueryKey, filters?: QueryFilters): void\n  removeQueries(arg1?: QueryKey | QueryFilters, arg2?: QueryFilters): void {\n    const [filters] = parseFilterArgs(arg1, arg2)\n    const queryCache = this.queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TPageData = unknown>(\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: ResetQueryFilters<TPageData>,\n    options?: ResetOptions,\n  ): Promise<void>\n  resetQueries(\n    arg1?: QueryKey | ResetQueryFilters,\n    arg2?: ResetQueryFilters | ResetOptions,\n    arg3?: ResetOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n    const queryCache = this.queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(filters?: QueryFilters, options?: CancelOptions): Promise<void>\n  cancelQueries(\n    queryKey?: QueryKey,\n    filters?: QueryFilters,\n    options?: CancelOptions,\n  ): Promise<void>\n  cancelQueries(\n    arg1?: QueryKey | QueryFilters,\n    arg2?: QueryFilters | CancelOptions,\n    arg3?: CancelOptions,\n  ): Promise<void> {\n    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3)\n\n    if (typeof cancelOptions.revert === 'undefined') {\n      cancelOptions.revert = true\n    }\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(cancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TPageData = unknown>(\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: InvalidateQueryFilters<TPageData>,\n    options?: InvalidateOptions,\n  ): Promise<void>\n  invalidateQueries(\n    arg1?: QueryKey | InvalidateQueryFilters,\n    arg2?: InvalidateQueryFilters | InvalidateOptions,\n    arg3?: InvalidateOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    return notifyManager.batch(() => {\n      this.queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries<TPageData = unknown>(\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries<TPageData = unknown>(\n    queryKey?: QueryKey,\n    filters?: RefetchQueryFilters<TPageData>,\n    options?: RefetchOptions,\n  ): Promise<void>\n  refetchQueries(\n    arg1?: QueryKey | RefetchQueryFilters,\n    arg2?: RefetchQueryFilters | RefetchOptions,\n    arg3?: RefetchOptions,\n  ): Promise<void> {\n    const [filters, options] = parseFilterArgs(arg1, arg2, arg3)\n\n    const promises = notifyManager.batch(() =>\n      this.queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) =>\n          query.fetch(undefined, {\n            ...options,\n            cancelRefetch: options?.cancelRefetch ?? true,\n            meta: { refetchPage: filters.refetchPage },\n          }),\n        ),\n    )\n\n    let promise = Promise.all(promises).then(noop)\n\n    if (!options?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData>\n  fetchQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    const defaultedOptions = this.defaultQueryOptions(parsedOptions)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (typeof defaultedOptions.retry === 'undefined') {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(defaultedOptions.staleTime)\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1: TQueryKey | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>>\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<InfiniteData<TData>> {\n    const parsedOptions = parseQueryArgs(arg1, arg2, arg3)\n    parsedOptions.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData\n    >()\n    return this.fetchQuery(parsedOptions)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData = unknown,\n    TError = unknown,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryKey: TQueryKey,\n    queryFn: QueryFunction<TQueryFnData, TQueryKey>,\n    options?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void>\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    arg1:\n      | TQueryKey\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg2?:\n      | QueryFunction<TQueryFnData, TQueryKey>\n      | FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    arg3?: FetchInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(arg1 as any, arg2 as any, arg3)\n      .then(noop)\n      .catch(noop)\n  }\n\n  resumePausedMutations(): Promise<void> {\n    return this.mutationCache.resumePausedMutations()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.mutationCache\n  }\n\n  getLogger(): Logger {\n    return this.logger\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.defaultOptions = options\n  }\n\n  setQueryDefaults(\n    queryKey: QueryKey,\n    options: QueryObserverOptions<unknown, any, any, any>,\n  ): void {\n    const result = this.queryDefaults.find(\n      (x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.queryDefaults.push({ queryKey, defaultOptions: options })\n    }\n  }\n\n  getQueryDefaults(\n    queryKey?: QueryKey,\n  ): QueryObserverOptions<any, any, any, any, any> | undefined {\n    if (!queryKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.queryDefaults.find((x) =>\n      partialMatchKey(queryKey, x.queryKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.queryDefaults.filter((x) =>\n        partialMatchKey(queryKey, x.queryKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several query defaults match with key '${JSON.stringify(\n            queryKey,\n          )}'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  setMutationDefaults(\n    mutationKey: MutationKey,\n    options: MutationObserverOptions<any, any, any, any>,\n  ): void {\n    const result = this.mutationDefaults.find(\n      (x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey),\n    )\n    if (result) {\n      result.defaultOptions = options\n    } else {\n      this.mutationDefaults.push({ mutationKey, defaultOptions: options })\n    }\n  }\n\n  getMutationDefaults(\n    mutationKey?: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> | undefined {\n    if (!mutationKey) {\n      return undefined\n    }\n\n    // Get the first matching defaults\n    const firstMatchingDefaults = this.mutationDefaults.find((x) =>\n      partialMatchKey(mutationKey, x.mutationKey),\n    )\n\n    // Additional checks and error in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      // Retrieve all matching defaults for the given key\n      const matchingDefaults = this.mutationDefaults.filter((x) =>\n        partialMatchKey(mutationKey, x.mutationKey),\n      )\n      // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n      if (matchingDefaults.length > 1) {\n        this.logger.error(\n          `[QueryClient] Several mutation defaults match with key '${JSON.stringify(\n            mutationKey,\n          )}'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.`,\n        )\n      }\n    }\n\n    return firstMatchingDefaults?.defaultOptions\n  }\n\n  defaultQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey extends QueryKey,\n  >(\n    options?:\n      | QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options?._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.defaultOptions.queries,\n      ...this.getQueryDefaults(options?.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.defaultOptions.mutations,\n      ...this.getMutationDefaults(options?.mutationKey),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.queryCache.clear()\n    this.mutationCache.clear()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}